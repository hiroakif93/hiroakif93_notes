library(igraph)
A = matrix(c(
c(1, 0.1, 0, -0.2),
c(0.1, 1, -0.2, 0),
c(0, -0.2, 1, 0.1),
c(-0.2, 0, 0.1, 1)),
ncol=4, nrow=4)
diag(A) = -runif(4)
A[c(4,7,10,13)] = -abs(rnorm(4, mean=0.05, sd=0.1))
A[c(2,5,12,15)] = abs(rnorm(4, mean=0.01, sd=0.01))
g = igraph::graph_from_adjacency_matrix(A, weighted = TRUE, mode="directed", diag=FALSE)
plot(g )
ms_ricker = \(N, r, A) exp( r*(1+A%*%N) ) * N
times = 300
sp = 4
cvmat = matrix(NA, ncol=4, nrow=100)
mat_list = c()
for(rep in 1:100){
diag(A) = -1
A[c(4,7,10,13)] = abs(rnorm(4, mean=0., sd=0.01))
A[c(2,5,12,15)] = abs(rnorm(4, mean=0.1, sd=0.05))
N0 = as.integer( runif(sp, 1, 10) )
mat = matrix(0, nrow=times, ncol=sp)
rmat = matrix(0, nrow=times, ncol=sp)
dxmat = rmat = matrix(0, nrow=times, ncol=sp)
amps = seq(0.05, 0.2, 0.05)
cvs = c()
par(mfrow=c(4,4))
for(a in amps[1:4]){
N = N0
mat = matrix(0, nrow=times, ncol=sp)
rmat = matrix(0, nrow=times, ncol=sp)
env1 = sin(seq(1,1000,a)[1:times])
#env2 = cos(seq(1,100,a)[1:times])
env2 = -sin(seq(1,1000,a)[1:times])
for(i in 1:times) {
r = c(1, 0.8, 1, 0.8)
r[1:2] = r[1:2] +sapply(1:2, function(x)env1[i]+abs(rnorm(1, sd=0.2)))
r[3:4] = r[3:4] +sapply(1:2, function(x)env2[i]+abs(rnorm(1, sd=0.2)))
N = ms_ricker(N, r, A)
mat[i,]=N+rnorm(sp, sd=0.01)
rmat[i,]=r
dxmat[i,]=r*(1+A%*%N)
}
cv = apply(mat[50:nrow(mat),], 2, function(x)sd(x)/mean(x))
if( !any(is.na(cv)) ){
mat_list[[rep]][[paste("amp",a)]] = mat
plot(0, type="n", ylim=range(mat), xlim=c(1,times))
for(i in 1:sp)lines(mat[,i], col=i)
mat_scale = apply(mat, 2, scale)
plot(0, type="n", ylim=range(mat_scale), xlim=c(1,times))
for(i in 1:sp)lines(mat_scale[,i], col=i)
plot(0, type="n", ylim=range(rmat), xlim=c(1,times))
for(i in 1:sp)lines(rmat[,i], col=i)
plot(0, type="n", ylim=range(dxmat), xlim=c(1,times))
for(i in 1:sp)lines(dxmat[,i], col=i)
}
cvs = c(cvs, mean(cv))
}
cvmat[rep,] = cvs
}
library(rUIC)
uic_wrap = function (block, lib_var, tar_var, cond_var = NULL, tp = 0, alpha=NULL, num_surr=10000)
{
simp_xy <- simplex(block, lib_var=lib, cond_var=tar, E=E_range, tau=1, tp=1, alpha=0.05, num_surr=num_surr)
Exy = which.min(simp_xy$pval)
uic_xy <- uic(block, lib_var=lib, cond_var=tar, E=Exy, tau=1, tp=tp, num_surr=num_surr)
uic_xy$lib = lib
uic_xy$tar = tar
uic_xy$alpha = ifelse(is.null(alpha), NA, alpha)
return(res)
}
ts_scale = apply(mat_list[[1]][[1]], 2, scale)
ts_scale = apply(mat_list[[1]][[1]], 2, scale)
simp_xy <- simplex(ts_scale, lib_var=1, cond_var=2, E=1:10, tau=1, tp=1, alpha=0.05, num_surr=10000)
ts_scale
ts_scale = as.data.frame(apply(mat_list[[1]][[1]], 2, scale))
ts_scale
head(ts_scale)
simp_xy <- simplex(ts_scale, lib_var=1, cond_var=2, E=1:10, tau=1, tp=1, alpha=0.05, num_surr=10000)
simp_xy
uic.optimal(ts_scale,
lib_var=1, tar_var=1,
E=1:10, tau=1, tp=-1, num_surr=1000)
uic.optimal(ts_scale,
lib_var=1, tar_var=2,
E=1:10, tau=1, tp=-1, num_surr=1000)
expand.grid(1:ncol(ts_scale), 1:ncol(ts_scale))
res = c()
for(i in 1:nrow(set)){
res = rbind(res, uic.optimal(ts_scale,
lib_var=set[i,1], tar_var=set[i,2],
E=1:20, tau=1, tp=-1, num_surr=1000)
)
}
set = expand.grid(1:ncol(ts_scale), 1:ncol(ts_scale))
res = c()
for(i in 1:nrow(set)){
res = rbind(res, uic.optimal(ts_scale,
lib_var=set[i,1], tar_var=set[i,2],
E=1:20, tau=1, tp=-1, num_surr=1000)
)
}
View(set)
View(res)
which(res$pval < 0.05)
set[which(res$pval < 0.05)]
set[which(res$pval < 0.05),]
res = cbind(set, res)
View(res)
ts_scale = as.data.frame(apply(mat_list[[1]][[1]], 2, scale))[100:300,]
set = expand.grid(1:ncol(ts_scale), 1:ncol(ts_scale))
res = c()
for(i in 1:nrow(set)){
res = rbind(res, uic.optimal(ts_scale,
lib_var=set[i,1], tar_var=set[i,2],
E=1:20, tau=1, tp=-1, num_surr=1000)
)
}
for(i in 1:nrow(set)){
res = rbind(res, uic.optimal(ts_scale,
lib_var=set[i,1], tar_var=set[i,2],
E=1:20, tau=1, tp=-1, num_surr=1000)
)
}
res = cbind(set, res)
set[which(res$pval < 0.05),]
res
res[which(res$pval < 0.05),]
ts_scale = as.data.frame(apply(mat_list[[1]][[1]], 2, scale))[100:300,]
set = expand.grid(1:ncol(ts_scale), 1:ncol(ts_scale))
res = c()
res = c()
for(i in 1:nrow(set)){
res = rbind(res, uic.optimal(ts_scale,
lib_var=set[i,1], tar_var=set[i,2],
E=1:20, tau=1, tp=-1, num_surr=10000)
)
}
res = cbind(set, res)
res[which(res$pval < 0.05),]
as.matrix(set[which(res$ete > 0), ]) |>
graph_from_edgelist()
as.matrix(set[which(res$ete > 0),2:1 ]) |>
graph_from_edgelist()
as.matrix(set[which(res$ete > 0),2:1 ]) |>
graph_from_edgelist(diag=FALSE)
?graph_from_edgelist
as.matrix(set[which(res$ete > 0),2:1 ]) |>
graph_from_edgelist() |>
plot(graph_from_edgelist)
as.matrix(set[which(res$ete > 0),2:1 ]) |>
graph_from_edgelist() |>
plot()
res = c()
for(i in 1:nrow(set)){
res = rbind(res, uic.optimal(ts_scale,
lib_var=set[i,1], tar_var=set[i,2],
E=1:10, tau=1, tp=-c(0:5), num_surr=10000)
)
}
for(i in 1:nrow(set)){
res = rbind(res, uic.optimal(ts_scale,
lib_var=set[i,1], tar_var=set[i,2],
E=1:10, tau=1, tp=-c(0:5), num_surr=10000)
)
}
res = cbind(set, res)
res[which(res$pval < 0.05),]
View(res)
unique(res[which(res$pval < 0.05),1:2])
as.matrix(unique(res[which(res$pval < 0.05),1:2])) |>
graph_from_edgelist() |>
plot()
matrix(colnames(res))
unique(res[which(res$pval < 0.05),c(1:2, 13)])
as.matrix(unique(res[which(res$pval < 0.01),1:2])) |>
graph_from_edgelist() |>
plot()
as.matrix(unique(res[which(res$pval < 0.0),1:2])) |>
graph_from_edgelist() |>
plot()
as.matrix(unique(res[which(res$pval <= 0.0),1:2])) |>
graph_from_edgelist() |>
plot()
library(tidyverse)
set|>set_names(c("lib", "tar"))
colnames(res)[1:2] = c("lib", "tar")
res|>
group_by(tar) |>
mutate(
qth = p.adjust(pval, method='BY'),
cand_cause = ifelse(
qth < pval_th &
ete == max(ete) &
tp < 0, 1, 0)
)|>
ungroup()
res|>
group_by(tar) |>
mutate(
qth = p.adjust(pval, method='BY'),
cand_cause = ifelse(
qth < pval &
ete == max(ete) &
tp < 0, 1, 0)
)|>
ungroup()
uic_res = res|>
group_by(tar) |>
mutate(
qth = p.adjust(pval, method='BY'),
cand_cause = ifelse(
qth < pval &
ete == max(ete) &
tp < 0, 1, 0)
)|>
ungroup()
uic_res
View(uic_res)
seq_test <- rep(0, nrow(uic_res))
idx <- which(uic_res$cand_cause>0)
seq_test[idx[which.max(uic_res$ete[idx])]] <- 1
while (1) {
#　UICの結果で有意かつETE最大でなかったもの
idx <- which(uic_res$cand_cause>0 & seq_test==0)
#　UICの結果で有意かつETE最大でなかったものがない＝これ以上調べても強い因果がない時
if (length(idx) == 0) break
#　最大のETEを持つ因果
z <- which.max(seq_test)
cond_tp=-uic_res$tp[z]
cond=uic_res$tar[z]
make_lag = \(x, tp) embed(c(rep(NA,tp),ts_scale[,2]), tp+1)[,tp+1]
fun = ifelse(cond_tp==0, \(x)ts_scale[,x], make_lag)
lag_cond = fun(cond, cond_tp)|> as.data.frame() |>setNames(cond)
#　最大のETEを持つ因果をConditionにしたとき、因果関係が残るのかを検定
out.cond = foreach(j=idx, .packages = c('rUIC'), .combine='rbind')%dopar%{
tar = uic_res$tar[j]
tar_tp = uic_res$tp[j]
block = cbind(ts_scale[,c(lib, tar)], lag_cond)
uic_opt_xy =
uic_wrap(block=block, lib_var=lib, tar_var=tar, cond=cond,
tp=tar_tp, alpha = 0.05)
}
#　最大のETEを持つ因果を更新
r <- max(seq_test)
seq_test[idx[which.max(out.cond$ete)]] <- r+1
#　indirectとして判断された因果
seq_test[idx[out.cond$pval>=pval_th]]    <- -r
}
seq_test
uic_res$seq_test <- seq_test
uic_res
seq_test <- rep(0, nrow(uic_res))
idx <- which(uic_res$cand_cause>0)
seq_test[idx[which.max(uic_res$ete[idx])]] <- 1
#　UICの結果で有意かつETE最大でなかったもの
idx <- which(uic_res$cand_cause>0 & seq_test==0)
#　UICの結果で有意かつETE最大でなかったものがない＝これ以上調べても強い因果がない時
if (length(idx) == 0) break
idx
#　UICの結果で有意かつETE最大でなかったもの
idx <- which(uic_res$cand_cause>0 & seq_test==0)
uic_res$cand_cause>0
uic_res$cand_cause
uic_res = res |>
group_by(tar) |>
mutate(
qth = p.adjust(pval, method='BY'),
cand_cause = ifelse(
qth < 0.05 &
ete == max(ete) &
tp < 0, 1, 0)
)|>
ungroup()
uic_res
seq_test <- rep(0, nrow(uic_res))
idx <- which(uic_res$cand_cause>0)
seq_test[idx[which.max(uic_res$ete[idx])]] <- 1
seq_test
while (1) {
#　UICの結果で有意かつETE最大でなかったもの
idx <- which(uic_res$cand_cause>0 & seq_test==0)
#　UICの結果で有意かつETE最大でなかったものがない＝これ以上調べても強い因果がない時
if (length(idx) == 0) break
#　最大のETEを持つ因果
z <- which.max(seq_test)
cond_tp=-uic_res$tp[z]
cond=uic_res$tar[z]
make_lag = \(x, tp) embed(c(rep(NA,tp),ts_scale[,2]), tp+1)[,tp+1]
fun = ifelse(cond_tp==0, \(x)ts_scale[,x], make_lag)
lag_cond = fun(cond, cond_tp)|> as.data.frame() |>setNames(cond)
#　最大のETEを持つ因果をConditionにしたとき、因果関係が残るのかを検定
out.cond = foreach(j=idx, .packages = c('rUIC'), .combine='rbind')%dopar%{
tar = uic_res$tar[j]
tar_tp = uic_res$tp[j]
block = cbind(ts_scale[,c(lib, tar)], lag_cond)
uic_opt_xy =
uic_wrap(block=block, lib_var=lib, tar_var=tar, cond=cond,
tp=tar_tp, alpha = 0.05)
}
#　最大のETEを持つ因果を更新
r <- max(seq_test)
seq_test[idx[which.max(out.cond$ete)]] <- r+1
#　indirectとして判断された因果
seq_test[idx[out.cond$pval>=pval_th]]    <- -r
}
seq_test
seq_test <- rep(0, nrow(uic_res))
idx <- which(uic_res$cand_cause>0)
seq_test[idx[which.max(uic_res$ete[idx])]] <- 1
#　UICの結果で有意かつETE最大でなかったもの
idx <- which(uic_res$cand_cause>0 & seq_test==0)
idx
uic_res$cand_cause
uic_res$cand_cause>0
seq_test==0
uic_res$cand_cause>0 & seq_test==0
seq_test
uic_res$seq_test <- seq_test
uic_res
uic_res$qth
unique(res[which(uic_res$qth < 0.05 & uic_res$seq_test >= 0),c(1:2, 13)])
as.matrix(unique(res[which(uic_res$qth < 0.05 & uic_res$seq_test >= 0),c(1:2, 13)])) |>
graph_from_edgelist() |>
plot()
as.matrix(unique(res[which(uic_res$qth < 0.05 & uic_res$seq_test >= 0),c(2:1)])) |>
graph_from_edgelist() |>
plot()
as.matrix(unique(res[which(uic_res$qth < 0.05 & uic_res$E >= 2),c(2:1)])) |>
graph_from_edgelist() |>
plot()
as.matrix(unique(res[which(uic_res$qth < 0.05 & uic_res$E >= 1),c(2:1)])) |>
graph_from_edgelist() |>
plot()
as.matrix(unique(res[which(uic_res$qth < 0.05 & uic_res$E == 1),c(2:1)])) |>
graph_from_edgelist() |>
plot()
as.matrix(unique(res[which(uic_res$qth < 0.05 & uic_res$tp <= 0),c(2:1)])) |>
graph_from_edgelist() |>
plot()
res[which(uic_res$qth < 0.05 & uic_res$tp <= 0),c(2:1)]
unique(res[which(uic_res$qth < 0.05 & uic_res$seq_test >= 0),])
sin(0)
si(0.1)
sin(0.1)
